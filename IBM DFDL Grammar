Normal DFDL (Open Standard)

Each DFDL schema works independently.

If two flows import same schema â†’ each compiles its own copy.

No shared runtime model â†’ less efficient, more memory use.

Behavior depends on the vendor implementation.
IBM DFDL Grammar (IIB / ACE Specific)

IBM ne optimization kiya â†’ One Compiled Grammar per Application Domain.

âœ… Key Points:

Single Compiled Grammar per Application

Application ke andar jitne bhi DFDL schemas hain â†’
IBM unko merge karke ek single grammar banata hai.

ğŸ”¹ Result: Faster parsing + Less memory usage.

Isolation

Har Application / Integration Server apna grammar domain banata hai.

Schemas ek Application ke dusre Application me visible nahi hote.

ğŸ”¹ Result: Safe & isolated runtime
Flows without Application

Agar flow Application ke bahar deploy hai â†’
IBM uske liye independent grammar domain banata hai (Integration Server level).

Schema Merge

Agar ek Application ke multiple flows different schemas use karte hain â†’
IBM sab ko merge karke ek combined grammar banata hai.

Same schema reused in multiple flows â†’ compiled once, reused everywhere
Example

Application: BankingApp

Flow-1 â†’ CustomerDFDL.xsd

Flow-2 â†’ TransactionDFDL.xsd

Flow-3 â†’ CustomerDFDL.xsd (same as Flow-1)

Runtime:
ğŸ‘‰ IBM merges both schemas â†’ single compiled grammar.
âœ”ï¸ CustomerDFDL used once
âœ”ï¸ Shared by all flows â†’ Fast & Memory Efficient
IBM DFDL Grammar = single compiled, shared, and isolated schema model per Application â†’ fast, efficient, and well-governed runtime
DFDL Grammar â€” Application vs Independent Flows (Short Notes)
ğŸ”¹ 1. Case 1 â€“ Inside Application

Example: PaymentApp

Flow-1 â†’ CardTxnDFDL.xsd

Flow-2 â†’ UPITxnDFDL.xsd

IBM Behavior:
ğŸ‘‰ IBM sab schemas ko merge karke ek single compiled grammar banata hai per Application.

Result:

Grammar shared among all flows in the same App.

Faster parsing, less memory.

Grammar isolated â†’ dusre Applications use nahi kar sakte.

âœ… Domain: Application-level grammar domain

Case 2 â€“ Outside Application (Independent Flows)

Example:

Flow-A â†’ InvoiceDFDL.xsd

Flow-B â†’ ReceiptDFDL.xsd

Deployed directly to Integration Server (no App).

IBM Behavior:
ğŸ‘‰ IBM unhe ek Integration Server-level grammar domain ke andar merge karta hai.

Result:

Ek combined grammar for all standalone flows.

Separate from any Application grammar.

âœ… Domain: Integration Server-level grammar domain

Application â†’ Grammar per Application.
Standalone Flows â†’ Grammar per Integration Server.
In both cases, schemas merge â†’ ek single compiled grammar per domain âš¡
Two Ways to Deploy Flows
âœ… A. Inside an Application

Create an Application (e.g., PaymentApp).

Add:

.msgflow (message flows)

.dfdl.xsd (DFDL schemas)

.esql (Compute logic)

Deploy the whole Application as one unit.

Application = Container / Boundary for all related artifacts.

ğŸŸ¢ Grammar Level: Application-level compiled grammar
ğŸŸ¢ Benefits:

Organized & isolated

Reusable within same Application

Better governance
Directly to Integration Server (Without Application)

No Application created.

Directly deploy .msgflow & its resources to Integration Server.

Useful for small / micro flows or quick testing.

IBM kehta hai:

â€œAnything not in an Application exists in its own Integration Server level domain.â€

ğŸŸ¢ Grammar Level: Integration Server-level grammar domain
ğŸŸ¢ Benefits:

Simple setup

Faster for lightweight projects

No Application overhead
Flows IBM IIB/ACE me Application ke andar ya direct Integration Server pe deploy ho sakte hain.
Grammar dono case me banta hai â€” bas scope alag hota hai
